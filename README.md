# Arborist
Arborist is a node based application to print out the author's favourite tree.  It is built using Express, and uses Jest for tests.

## Development
Arborist can be developed in two ways:

- For traditional "local" development, a development container configuration has been included.  When the folder is loaded into VS Code, a prompt will be visible asking the user if they would like to run the project in a container, clicking "Run in container" will build the project's container alongside helpful development utilities.
- For development against a more "production-like" environment, Kubernetes manifests will be included for each environment under the `.k8s` folder.
  - To bootstrap a local k8s environment, please run:
  ```
    ./build-and-deploy
  ```
    in order to build and deploy a local k8s copy of the application.

## Tests
Testing is handled by [Jest](https://jestjs.io/) and [Supertest](https://github.com/ladjs/supertest), and test reports can be generated by running:
```
npm test
```

Tests are kept within the `__tests__` folder, and the structure of this folder should match the folder structure of the application.  As an example, for a file located at `/foo/bar.js`, a corresponding test file would be located at `/__tests__/foo/bar.test.js`.


## Bonus Questions
### How would you apply the configs to multiple environments (staging vs production)?
See `/.k8s/staging` or `/.k8s/production`.  Essentially, using [Kustomize](https://kustomize.io/) it's trivial to override common configuration for different environments.  Given that Kustomize is natively bundled with `kubectl`, it makes for a more universal solution for this than something like Helm, although Helm could also be used to achieve the same result.

### How would you auto scale the deployment based on network latency instead of CPU?
I didn't end up implementing this for time constraints, but there are a couple of ways of going about this.

If you're using Prometheus, you can leverage the [prometheus-adapter](https://github.com/kubernetes-sigs/prometheus-adapter) and HPAs to target latency specific metrics.

Alternatively, if you're looking for a more general solution, something like [KEDA](https://keda.sh/) may be a better choice if you're pulling metrics from a variety of different sources (eg. Prometheus as well as DataDog et al).
